package my_threads.thread_producer_and_consumer;

public class Base {
    public static void main(String[] args) {
        //生产者和消费者（等待唤醒机制）
        //一个经典的多线程协作的模式，打破随机的机制，让两个线程轮流执行
        //其中一条线程叫做生产者，负责生产数据
        //另一条叫消费者，负责消费数据
        //示例：顾客作为消费者，厨师作为生产者，二者之间存在桌子，当桌子上存在食物，由顾客执行，当桌子上不存在食物，由厨师执行
        //理想情况是生产者消费者轮流取得桌子控制权，交替执行，但实际有时并非如此

        //两种情况
        // 1 消费者等待---当桌子上没东西，CPU执行权被顾客抢到，由于没东西，顾客只能等待（wait），CPU的执行权一定会被厨师抢到
        //      厨师拿到执行权后开始做食物，做完放到桌子上，然后执行唤醒（notify），唤醒顾客
        // 2 生产者等待---当桌子上有东西，但仍旧是厨师抢到CPU的执行权，那厨师就要等待

        //完整执行流程
        //  消费者---1 判断桌子上是否有食物
        //          2 如果没有就等待
        //          3 如果有就开吃
        //          4 吃完之后唤醒厨师继续做
        //  生产这---1 判断桌子上是否有食物
        //          2 有 等待
        //          3 没有 制作食物
        //          4 把食物放在桌子上
        //          5 叫醒等待的消费者开吃

        //常见方法
        //void wait() 当前线程等待，直到被其他线程唤醒
        //void notify() 随机唤醒单个线程
        //void notifyall() 唤醒所有线程

        
    }
}
