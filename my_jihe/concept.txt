集合体系结构
    Collection --- 单列集合，一次添加一个
    Map --- 双列集合，每次添加一对数据
单列集合
    有标注的事接口，其余是实现类
    顶层Collection（Interface）
        -List（Interface）：添加的元素有序，可重复，有索引，有序指存和取的顺序一样
            -ArrayList
            -LinkedList
            -Vector
        -Set（Interface）：添加的元素无序，不重复，无索引
            -HashSet
                -LinkedHashSet
            -TreeSet
    Collection  --- 单列集合的祖宗接口，共性的方法
        遍历方法：迭代器遍历、增强for遍历、Lambda表达式遍历。普通for不再普适，因为Set系列没有索引
        迭代器遍历：不依赖索引
            在java中的类是Iterator，是集合专用的遍历方式
            可以用Iterator<E> iterator() 方法返回迭代器对象，默认指向集合的零索引
            然后用boolean hasNext() 判断当前位置是否有元素，有则返回true
            E next() 获取当前位置的元素，并将迭代器对象移向下一个位置

数据结构

泛型
    如果没有给集合指定类型，会默认所有传入的对象都是Object类型
    此时可以向集合中添加任意的数据类型
    这时，在使用数据的时候无法使用它的特有行为
    所以Java推出了泛型 --- 也就是<>中的内容
泛型拓展
    Java中的泛型是伪泛型，在由Java文件转为class字节码文件时，会进行泛型的擦除，在编译的时候会检查存入的数据的类型
    指定泛型的具体对象后，传递数据时，可以传入该类类型或者其子类类型
    泛型可以在很多地方进行定义
        类后 --- 泛型类
            修饰符 class 类名<类型>{}
            例如 public class ArrayList<E>{} 创建该类对象时，E就确认类型
            此处的E可以理解为变量，但不是用来记录数据的，而是记录数据的类型，可以写成 T E K V 等
        方法上 --- 泛型方法 
            解决办法有二 1 使用类名后面定义的泛型，2 在方法声明上定义自己的泛型（只有本方法能用）
            修饰符<类型> 返回值类型 方法名(类型 变量名)
        接口后面 --- 泛型接口
            修饰符 interface 接口名<类型>{}
            重点：如何使用一个带泛型的接口
                方式一：实现类给出具体的类型
                方式二：实现类延续泛型，创建对象时再确定
                    例如 public class MyArrayList3<E> implements list<E> {}
泛型的继承和通配符
    泛型不具备继承性 但数据具备继承性

树
    度：每个结点子结点的数量
    树高：总层数
    根节点：最顶层的结点
二叉查找树 --- 每个结点最多有两个结点 任意结点左子树的值均小于该结点，右子树的值均大于该节点
    添加结点规则：小的存左边，大的存右边，一样的不存
二叉查找树前序遍历 --- 当前，左，右
    中序遍历 --- 左 当前 右 遍历出来的数据按照从小到大排列，最为常用
    后序遍历 --- 左 右 当前
    层序遍历 --- 一层一层遍历
二叉查找树的弊端
    极端情况会变成链表
平衡二叉树
    规则 任意结点左右子树高度差不超过1
    机制：1 左旋
            确定支点：从添加的结点开始，不断的往父节点找不平衡的结点（左右子树高度差不为1），将其作为支点
            把支点左旋降级，变成左子结点
            晋升原来的右子节点
            当进行复杂的树平衡时，最后一步可能变为
                原先的右子节点变成新的父节点，并把多余的左子结点出让，给降级的根节点当右子节点
        2 右旋
            确定支点：同左旋
            把支点右旋降级，变成右子节点
            晋升原来的左子节点
            复杂情况最后一步变为
                原先的左子树变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子结点
        平衡二叉树需要旋转的四种情况
            左左：根节点的左子树的左子树有结点插入，导致二叉树不平衡，进行一次右旋即可
            左右：当根节点的左子树的右子树有结点插入，导致二叉树不平衡，要先局部左旋，再整体右旋
            右右：当根节点右子树的右子树有结点插入导致不平衡，进行一次左旋即可
            右左：当根节点右子树的左子树有结点插入导致不平衡，要先局部右旋，再整体左旋
        触发时机：当添加一个节点后，该树不再是平衡二叉树
红黑树
    红黑树是一种能自平衡的二叉查找树，是计算机科学用到的一种数据结构
    1972年出现，当时被称为平衡二叉B树，后来，1978年被修改为如今的红黑树
    是一种特殊的二叉树，红黑树的每一个结点都有存储位表示结点的颜色
    每一个节点可以是红或黑，红黑树不是高度平衡的，他的平衡规则是通过红黑规则实现的
红黑规则
    1 每一个结点或是红色的，或是黑色的
    2 根节点必须是黑色的
    3 如果一个结点没有子结点或者父节点，则该结点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的
    4 如果某一个结点是红色的，那么他的子结点必须是黑色的（不能出现两个红色结点相连的情况）
    5 对每个结点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点
红黑树节点的组成
    父节点地址值 结点值 左右结点地址值 颜色
红黑树添加节点的规则
    添加节点默认是红色的（效率高）
    添加根结点 --- 直接变为黑色
    添加非根节点 --- 父节点是黑色 --- 不需要任何操作
                ---父节点是红色 --- 叔叔是红色 --- 将父设为黑色，将叔叔设为黑色
                                             --- 将祖父设为红色
                                             --- 如果祖父为根，再将根变为黑色
                                             --- 如果祖父非根，将祖父设置为当前节点再进行其他判断

                               --- 叔叔黑色，当前节点是父的右孩子 --- 把父作为当前节点并左旋，再进行判断

                               --- 叔叔黑色，当前节点是父的左孩子 --- 将父设置为黑色
                                                               --- 将祖父变为红色
                                                               ---以祖父为支点进行右旋
红黑树的增删改查性能都很好

Set系列集合
    无序 --- 存和取的顺序不一致
    不可重复 --- 可以去除重复
    无索引 --- 没有带索引的方法
Set集合的实现类
    HashSet：无序、不重复、无索引
    LinkedHashSet：有序、不重复、无索引
    TreeSet：可排序、不重复、无索引

Set接口中的方法基本上与Collection的API一致


使用场景
    如果想要集合中的元素可重复 --- ArrayList 基于数组
        如果还满足当前的增删操作明显多于查询 --- 使用LinkedList 基于链表
    如果想去重 --- HashSet 基于哈希表
        如果还想保证存取顺序 --- LinkedHashSet 基于哈希表和双链表 效率略低于HashSet
        如果还想排序 --- TreeSet 基于红黑树



双列集合特点
    分为两列，左侧为键，右侧为值，键不可重复，值可以重复，键和值一一对应
    两列一起称为键值对/键值对对象/Entry
体系结构
    Map --- HashMap --- LinkedHashMap
        --- TreeMap

可变参数
    