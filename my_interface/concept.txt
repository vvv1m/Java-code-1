接口
    为什么有接口
        接口就是一种规则，用于处理父类的子类中有多个但并非全部的共性，是对行为的抽象
    接口的应用
        当需要的不是一个继承体系，而是侧重于要做的事，就可以应用接口
    如何定义一个接口
        public interface 接口名{}
    如何使用一个接口
        接口不能实例化
        接口和类是实现关系，通过implements关键字表示
            public class 类名 implements 接口名{}
        接口的子类称为实现类
            要么重写接口中所有抽象方法
            要么是抽象类
        注：接口和类的关系可以多实现
                public class 类名 implements 接口1, 接口2{}
            实现类还可以继承一个类的同时实现多个接口
                public class 类名 extends 父类 implements 接口1, 接口2{}
    接口中成员的特点
        成员变量    
            只能是常量
            默认修饰符 public static final //没写也会自动加上， 规则不可变
        构造方法
            没有
        成员方法
            只能是抽象方法，默认修饰public abstract
    接口和类之间的关系
        类与类
            继承关系，只能单继承，可以多层继承
        类与接口
            实现关系，可以单、多实现，可继承同时实现多个接口
            当多个接口中有重名的方法时，重写一次即可
        接口与接口
            继承关系，可以单继承，也可以多继承
            细节：实现类如果实现的是最下面的子接口，就要重写所有的抽象方法
    JDK8后接口新增的方法
        JDK8后可以定义有方法体的方法。（默认、静态）
            原因
                JDK8以前，如果接口中发生改动，所有实现该接口的类都需要同步改动，所以想要在接口加新的规则，
            又不报错，在接口里定义有方法体的方法就好了
            JDK8后新增的默认方法
                定义默认方法，需要用default修饰---作用就是解决接口升级问题
                public default 返回值类型 方法名(参数列表){}
                注：默认方法不是抽象方法，所以不强制被重写，但是如果被重写，重写的时候要去掉default关键字
                    public可以省略，但default不能省略
                    如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写
            JDK8后新增的静态方法
                定义格式同正常静态方法
                注：接口中的静态方法只能通过接口名调用，不能通过实现类名或对象名调用
                    public可以省略，但static不能
        JDK9后可以定义私有方法
            原因：方便定义抽取出来的重复代码，只为接口提供服务，不需要外类访问 
            定义有两种格式
                private void show(){} 为默认方法服务
                private static void method(){} 为静态方法服务
    接口的应用
        接口代表规则，是行为的抽象。想要让哪个类拥有某个行为，就让这个类实现对应的接口即可
        当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方法称之为接口多态
    适配器设计模式
        设计模式：一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了
            可重用代码、让代码更容易被他人理解、保证代码的可靠性、程序的重要性，也就是各种套路
        适配器设计模式就可以解决接口与接口实现类之间的矛盾问题，当接口中抽象方法过多，但只使用其中一部
    分的时候，就可以使用适配器设计模式，编写中间类xxx（接口名）Adapter，实现对应接口即可
        为了避免其他类创建适配器类的对象，中间的适配器类用abstract修饰
        如果子类还需要继承其他类，可以让适配器继承那个类，再让子类继承适配器